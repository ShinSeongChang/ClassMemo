===================
FINITE STATE MACHINE

1.FSM 이란?

FSM : 유한 상태 기계 ' 유한한 상태를 가진 기계'

FSM은 한번에 오로지 하나의 상태만을 가지게 되는데 이를 현재상태 (Current State) 라는 임의의 주어진 시간의
상태를 칭합니다.
FSM의 핵심은 단하나의 상태만을 가진다는 점이다.

. FSM 게임에서의 사용 예씨

- 플레이어, 적, NPC, 배경, 체력바 등 하나의 특정 오브젝트의 행동 관리



 FSM 왜 사용하는가?

1. 직관적인ㄷ ㅗ표로 나타내므로 Ai의 구조를 프로그래머 이외에 제 3자가 쉽게 확인 / 설계 가능하다.
2. 정해진 규칙이 있기 때문에 프로그래머가 더 안정성 높은 코드를 만들어 낼 수 있따.
3. 각각의 상태로 나뉘어져 있기 때문에 새로운 상태의 추가 및 삭제가 용의하다.

FSM 장점

1. 간단하고 직관적인 구조
2. 유지보수 용이성
3. 확장성
4. 상태 추적

FSM 단점

1. 단순한 구조
2. 복잡한 상태 변화 처리
3. 높은 결합도

유한상태머신은 대부분의 경우 유용하지만 , 모든 상황에서 적합하지 않을 수 있다.
적의 행동 패턴, 플레이어 상태변화 등의 비교적 단순하고 확실한 한 패턴의 로직을 구현하는데 유용하지만,
상태 변화가 복잡하거나 상태가 다양한 조건에 의해 결정되어야 하는 경우에는 구현이 복잡해질 수 있고, 




================================
State Pattern

행동 트리(Behavior Tree)
ppt 참고




================================

Object Pooling


1. Object Pooling의 정의

- 메모리 할당 및 해제 오버헤드(어떠한 일을 수행하거나 처리하는데 있어서 부가적, 간접적 시간과 비용)를 줄이기 
위해 객체를 재사용하는 디자인 패턴이다.

- 동작 방식 
 1) 오브젝트 생성 및 보관 : SetActive(false)
 2) 오브젝트 호출 시 보관된 오브젝트 호출 : 사용 SetActive(true)
 3) 사용 완료된 오브젝트는 보관, 비활성화 : 미사용 SetActive(false)

- GC (Garbage Collector)
 필요없는 메모리를 수집하여 해당 공간의 할당을 해제하는 것
-> GC의 처리과정 ppt 참고해볼 것

-메모리 단편화
 1) 내부 단편화
 2) 외부 단편화 

2. 오브젝트 풀링의 장 단점
 1) 장점 : 
 - 객체를 재활용 하므로 GC에 의한 메모리 관리 부하가 감소합니다.
 - 객체를 재사용하기 때문에 새로운 객체를 생성하는 오버헤드가 감소한다.
 - 객체 생성 및 삭제에 따른 메모리 단편화를 방지하여 프로그램의 메모리 사용을 최적화한다.








==========================================================


Dispose Pattern

1. Dispose Pattern 이란
 - 객체지향 프로그래밍에서 Dispose Pattern 은 메모리 누수를 방지하고, 리소스를 안전하게 해제하기 위해 사용되는
패턴이다.


2. Dispose Pattern이 필요한 이유
 -파일핸들, 네트워크 연결, 데이터베이스 연결등 외부 리소스를 관리해야할때 프로그래머가 직접 관리해야한다.

 1) 외부 리소스 관리
 2) 리소스 재사용과 관리




================================

Singleton Pattern

1. 디자인 패턴이란?
- 디자인 패턴들은 소프트웨어 디자인 과정에서 자주 발생하는 문제들에 대한 일반적인 해결책
- 싱글턴 패턴은 생성패턴에 해당된다 => 객체 생성에 관련된 패턴으로 객체의 생성 절차를 추상화 하는 패턴

2. 싱글턴 패턴이란?
- 싱글턴 패턴을 따르는 객체의 인스턴스를 하나만 유지
- 인스턴스된 싱글턴 클래스를 전역변수로 지정
- 모든 클래스에서 접근할수있게 하는 디자인 패턴

3. 사용하는 이유
- 전역에서 접근이 가능하기에 접근성이 용이
- 중복 생성과 메모리 낭비 방지
- 빠른 호출

4. 싱글턴 패턴의 문제점
- 결합도 문제 
 1) 정적 변수가 전혀 상관없는 클래스와 커플링이 생길 수 있습니다.
 2) 두 클래스 사이에 결합이 생겨서, 만약 한 클래스를 수정한다면 다른 한 클래스도 수정해야 하는 상황 생깁니다.

- 게으른초기화 문제
 1) 게임에서는 시스템을 초기화할 때 메모리 할당, 리소스 로딩 등으로 인해, 할 일이 많아 시간이 걸립니다.
 2) 필요할 때 초기화한다는 건 그 순간을 최대한 미룰 수 있어 괜찮은 아이디어지만
 3) 전투 도중에 시스템 초기화 작업을 수행한다면 중간에 프레임이 떨어지거나 게임 화면이 뚝둑 끊길 수 있다.   


-> 늦은 초기화 해결법
1) 객체의 초기화 시점에 집중
2) 로딩씬에서 모두 초기화

5. 멀티 스레드 상황 사용 예시 








============================

컴포넌트 패턴

1. 패턴을 사용하는 경우

- 한 클래스에서 여러 분야를 건드리고 있어서, 이들을 서로 디커플링 하고 싶다.
- 클래스가 거대해져서 작업하기가 어렵다.
- 여러 다른 기능을 공유하는 다양한 객체를 정의하고 싶다. 단 상속으로는 딱 원하는 부분만 골라서 재사용할 수가
  없다.

2. 상속

 = A IS B =

 - 장점
   1) 부모 클래스로부터 물려받은 부분은 다시 쓸 필요가 없기 때문에 재사용 면에 있어서 효율적이다.

 - 단점
   1) 부모, 조상 클래스가 될 공통된 최소 필수 집합을 개발자가 미리 예상하기가 힘들다.
   2) 컴포넌트들끼리 커플링이 심하다.


 = A HAS B =
 - 빈 컨테이너에 필요할 때마다 원하는 기능을 갖다 붙여 포함시키는 방식, 부품.


- AI, 물리, 렌더링, 사운드처럼 분야가 다른 코드끼리는 최대한 서로 모르는게 좋다.
클래스가 크다는것은 사소한 것을 찾아 수정하려해도 힘들다.


= 고르디우스의 매듭 =
- 커플링과 코드 길이 문제는 서로 악영향을 미친다.
- 한클래스가 너무 만ㄶ은 분야를 건드리다 보니 모든 프로그래머가 그 클래스를 작업해야 하는데, 클래스가 








